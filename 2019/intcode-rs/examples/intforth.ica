# an indirect-threaded mini-FORTH on intcode [WIP]

rel $2048 # stack starts at addr 2048 - allows ~ 2kw of heap
jz $0, $_next

ip: $thread

var_base: $10
var_latest: $exit_link
var_state: $0
var_here: $heap # TODO

thread: $lit
$3
$quadruple
$double
$lit
$41
$plus
$dup
$emit
$lit
$65535
$store
$lit
$65535
$fetch
$emit
$word
$find
$dfa
$emit
$word
$create
$lit
$docol
$comma
$_halt

# DOCOL is the inner interpreter
docol: add $0, rstack_bp, docol_push_target
add $0, ip, docol_push_target: 0
add $1, rstack_bp, rstack_bp
add $-1, ip, old_ip
add $1, old_ip: 0, ip
jz $0, $_next

# each word's layout is:
# link to previous word
# hidden flag
# immediate flag
# ASCIP name
# codeword
# code...

# first come variables

base_link: $0
$0
$0
.ascip "BASE" # (-- base)
base: $base_code
base_code: rel $1
add $0, var_base, (0)
jz $0, $_next

latest_link: $base_link
$0
$0
.ascip "LATEST" # (-- latest)
latest: $latest_code
latest_code: rel $1
add $0, var_latest, (0)
jz $0, $_next

state_link: $latest_link
$0
$0
.ascip "STATE" # (-- state)
state: $state_code
state_code: rel $1
add $0, var_state, (0)
jz $0, $_next

here_link: $state_link
$0
$0
.ascip "HERE" # (-- here)
here: $here_code
here_code: rel $1
add $0, var_here, (0)
jz $0, $_next

# then come proper words

double_link: $here_link
$0
$0
.ascip "DOUBLE" # (n -- n)
double: $docol
$dup
$plus
$exit

quadruple_link: $double_link
$0
$0
.ascip "QUADRUPLE" # (n -- n)
quadruple: $docol
$double
$double
$exit

lit_link: $quadruple_link
$0
$0
.ascip "LIT" # ( -- n)
lit: $lit_code
lit_code: rel $1
add $0, ip, lit_src
add $0, lit_src: 0, (0)
add $1, ip, ip
jz $0, $_next

drop_link: $lit_link
$0
$0
.ascip "DROP" # (x -- )
drop: $drop_code
drop_code: rel $-1
jz $0, $_next

dup_link: $drop_link
$0
$0
.ascip "DUP" # (x -- x x)
dup: $dup_code
dup_code: rel $1
add $0, (-1), (0)
jz $0, $_next

plus_link: $dup_link
$0
$0
.ascip "+" # (n1 n2 -- n1 + n2)
plus: $plus_code
plus_code: add (-1), (0), (-1)
rel $-1
jz $0, $_next

mult_link: $plus_link
$0
$0
.ascip "*" # (n1 n2 -- n1 * n2)
mult: $mult_code
mult_code: mul (-1), (0), (-1)
rel $-1
jz $0, $_next

incr_link: $mult_link
$0
$0
.ascip "INCR" # (n -- n + 1)
incr: $incr_code
incr_code: add $1, (0), (0)
jz $0, $_next

equals_link: $incr_link
$0
$0
.ascip "=" # (n1 n2 -- n1 = n2)
equals: $equals_code
equals_code: eq (-1), (0), (-1)
rel $-1
jz $0, $_next

lessthan_link: $equals_link
$0
$0
.ascip "<" # (n1 n2 -- n1 < n2)
lessthan: $lessthan_code
lessthan_code: lt (-1), (0), (-1)
rel $-1
jz $0, $_next

store_link: $lessthan_link
$0
$0
.ascip "!" # (val addr --)
store: $store_code
store_code: add $0, (0), store_dst
add $0, (-1), store_dst: 0
rel $-2
jz $0, $_next

fetch_link: $store_link
$0
$0
.ascip "@" # (addr -- val)
fetch: $fetch_code
fetch_code: add $0, (0), fetch_src
add $0, fetch_src: 0, (0)
jz $0, $_next

emit_link: $fetch_link
$0
$0
.ascip "EMIT" # (chr --)
emit: $emit_code
emit_code: out (0)
rel $-1
jz $0, $_next

key_link: $emit_link
$0
$0
.ascip "KEY" # (-- chr)
key: $key_code
key_code: rel $1
in (0)
jz $0, $_next

word_link: $key_link
$0
$0
.ascip "WORD" # (-- ptr len)
word: $word_code
word_code: rel $3
add $0, $0, (-1) # length
add $0, $0, (-2) # temporary for now...
word_skip_blanks: in (0)
# skip tab
eq (0), $9, (-2)
jnz (-2), $word_skip_blanks
# skip space
eq (0), $32, (-2)
jnz (-2), $word_skip_blanks
# skip LF
eq (0), $10, (-2)
jnz (-2), $word_skip_blanks
# skip CR
eq (0), $13, (-2)
jnz (-2), $word_skip_blanks
# else...
jz $0, $word_valid_char
word_til_blank: in (0)
eq (0), $9, (-2)
jnz (-2), $word_ret
eq (0), $32, (-2)
jnz (-2), $word_ret
eq (0), $10, (-2)
jnz (-2), $word_ret
eq (0), $13, (-2)
jnz (-2), $word_ret
word_valid_char: add (-1), $word_buf, word_dst
add $0, (0), word_dst: 0
add $1, (-1), (-1)
# check length!
eq (-1), $32, (-2)
jnz (-2), $word_ret
jz $0, $word_til_blank
word_ret: rel $-1
add $0, $word_buf, (-1)
jz $0, $_next
word_buf: .zeroes 32

number_link: $word_link
$0
$0
.ascip "NUMBER" # (ptr len -- num n-unparsed)
number: $number_code
number_code: rel $5 # temporaries: num n-unparsed char cnd neg
add $0, $0, (-3)
add $0, $0, (-4)
jz (-5), $number_ret # fail if 0-length input
add $0, (-6), number_first
eq $45, number_first: 0, (0) # check for negative sign
jz (0), $number_loop
# skip negative sign
add $-1, (-5), (-5)
add $1, (-6), (-6)

number_loop: jz (-5), $number_ret
add $0, (-6), number_src
add $0, number_src: 0, (-2)
lt (-2), $48, (-1)
jnz (-1), $number_fail
lt (-2), $58, (-1)
jnz (-1), $number_digit
lt (-2), $65, (-1)
jnz (-1), $number_fail
lt (-2), $91, (-1)
jnz (-1), $number_alpha
jz $0, $number_fail

number_digit: add $-48, (-2), (-2)
jz $0, $number_accum

number_alpha: add $-55, (-2), (-2)
jz $0, $number_accum

number_accum: lt (-2), var_base, (-1)
jz (-1), $number_fail
mul (-4), var_base, (-4)
add (-4), (-2), (-4)
add $-1, (-5), (-5)
add $1, (-6), (-6)
jz $0, $number_loop

number_fail: add $0, (-5), (-3)
number_ret: jz (0), $number_no_negate
mul $-1, (-4), (-4)
number_no_negate: rel $-5
add $0, (1), (-1)
add $0, (2), (0)
jz $0, $_next

find_link: $number_link
$0
$0
.ascip "FIND" # (ptr len -- dict-ptr)
find: $find_code
find_code: rel $3 # temporaries: cur_ptr cnd count
add $0, var_latest, (-2)
find_loop: eq $0, (-2), (-1)
jnz (-1), $find_ret

# load hidden flag and test
add $1, (-2), find_hidden_ptr
jnz find_hidden_ptr: 0, $find_next

# skip if length doesn't match
add $3, (-2), find_len
eq find_len: 0, (-3), (-1)
jz (-1), $find_next

# loop and check each char
add $0, $0, (0)
find_inner_loop: eq (-3), (0), (-1)
jnz (-1), $find_ret
add $4, (-2), find_word_name_ptr
add find_word_name_ptr, (0), find_word_name_ptr
add (-4), (0), find_sought_name_ptr
eq find_word_name_ptr: 0, find_sought_name_ptr: 0, (-1)
jz (-1), $find_next
add $1, (0), (0)
jz $0, $find_inner_loop

find_next: add $0, (-2), find_next_link
add $0, find_next_link: 0, (-2)
jz $0, $find_loop

find_ret: add $0, (-2), (-4)
rel $-4
jz $0, $_next

cfa_link: $find_link
$0
$0
.ascip ">CFA" # (dict-ptr -- codeword-ptr)
cfa: $cfa_code
cfa_code: add $3, (0), cfa_len_ptr
# codeword is at link + 4 + name-length
add cfa_len_ptr, cfa_len_ptr: 0, (0)
add $1, (0), (0)
jz $0, $_next

dfa_link: $cfa_link
$0
$0
.ascip ">DFA" # (dict-ptr -- data-ptr)
dfa: $docol
$cfa
$incr
$exit

# somewhat more "magic" words

create_link: $dfa_link
$0
$0
.ascip "CREATE" # (ptr len --)
create: $create_code
create_code: add $0, var_here, create_link_dst
add $0, var_latest, create_link_dst: 0
add $0, var_here, var_latest
add $1, var_here, create_hidden_dst
add $0, $0, create_hidden_dst: 0
add $2, var_here, create_imm_dst
add $0, $0, create_imm_dst: 0
add $3, var_here, create_len_dst
add $0, (0), create_len_dst: 0
add $4, var_here, var_here
create_copy_loop: jz (0), $create_ret
add $0, (-1), create_char_src
add $0, var_here, create_char_dst
add $0, create_char_src: 0, create_char_dst: 0
add $-1, (0), (0)
add $1, (-1), (-1)
add $1, var_here, var_here
jz $0, $create_copy_loop
create_ret: rel $-2
jz $0, $_next

comma_link: $create_link
$0
$0
.ascip "," # (ptr --)
comma: $comma_code
comma_code: add $0, var_here, comma_dst
add $0, (0), comma_dst: 0
add $1, var_here, var_here
rel $-1
jz $0, $_next

exit_link: $comma_link
$0
$0
.ascip "EXIT"
exit: $exit_code
exit_code: add $-1, rstack_bp, rstack_bp
add $0, rstack_bp, exit_pop_src
add $0, exit_pop_src: 0, ip
jz $0, $_next

_next: add $0, ip, _jnext1
add $0, _jnext1: 0, _jnext2
add $1, ip, ip
jz $0, _jnext2: 0

_halt: $halt_code
halt_code: hlt

# assumption: data stack will be larger than return stack
# return stack will have a max capacity of 64
rstack_bp: $rstack
rstack: .zeroes 64

# "heap" goes here...
heap: $0
