# an indirect-threaded mini-FORTH on intcode [WIP]

rel $stack
jz $0, $_next

ip: $thread

base: $10

thread: $lit
$3
$quadruple
$double
$lit
$41
$plus
$dup
$emit
$lit
$65535
$store
$lit
$65535
$fetch
$emit
$word
$number
$drop
$emit
$_halt

# DOCOL is the inner interpreter
docol: add $0, rstack_bp, docol_push_target
add $0, ip, docol_push_target: 0
add $1, rstack_bp, rstack_bp
add $-1, ip, old_ip
add $1, old_ip: 0, ip
jz $0, $_next

# each word's layout is:
# link to previous word
# hidden flag
# immediate flag
# ASCIP name
# codeword
# code...

$0
$0
$0
.ascip "DOUBLE" # (n -- n)
double: $docol
$dup
$plus
$exit

$double
$0
$0
.ascip "QUADRUPLE" # (n -- n)
quadruple: $docol
$double
$double
$exit

$quadruple
$0
$0
.ascip "LIT" # ( -- n)
lit: $lit_code
lit_code: rel $1
add $0, ip, lit_src
add $0, lit_src: 0, (0)
add $1, ip, ip
jz $0, $_next

$lit
$0
$0
.ascip "DROP" # (x -- )
drop: $drop_code
drop_code: rel $-1
jz $0, $_next

$drop
$0
$0
.ascip "DUP" # (x -- x x)
dup: $dup_code
dup_code: rel $1
add $0, (-1), (0)
jz $0, $_next

$dup
$0
$0
.ascip "+" # (n1 n2 -- n1 + n2)
plus: $plus_code
plus_code: add (-1), (0), (-1)
rel $-1
jz $0, $_next

$plus
$0
$0
.ascip "*" # (n1 n2 -- n1 * n2)
mult: $mult_code
mult_code: mul (-1), (0), (-1)
rel $-1
jz $0, $_next

$mult
$0
$0
.ascip "=" # (n1 n2 -- n1 = n2)
equals: $equals_code
equals_code: eq (-1), (0), (-1)
rel $-1
jz $0, $_next

$equals
$0
$0
.ascip "<" # (n1 n2 -- n1 < n2)
lessthan: $lessthan_code
lessthan_code: lt (-1), (0), (-1)
rel $-1
jz $0, $_next

$lessthan
$0
$0
.ascip "!" # (val addr --)
store: $store_code
store_code: add $0, (0), store_dst
add $0, (-1), store_dst: 0
rel $-2
jz $0, $_next

$store
$0
$0
.ascip "@" # (addr -- val)
fetch: $fetch_code
fetch_code: add $0, (0), fetch_src
add $0, fetch_src: 0, (0)
jz $0, $_next

$fetch
$0
$0
.ascip "EMIT" # (chr --)
emit: $emit_code
emit_code: out (0)
rel $-1
jz $0, $_next

$emit
$0
$0
.ascip "KEY" # (-- chr)
key: $key_code
key_code: rel $1
in (0)
jz $0, $_next

$key
$0
$0
.ascip "WORD" # (-- ptr len)
word: $word_code
word_code: rel $3
add $0, $0, (-1) # length
add $0, $0, (-2) # temporary for now...
word_skip_blanks: in (0)
# skip tab
eq (0), $9, (-2)
jnz (-2), $word_skip_blanks
# skip space
eq (0), $32, (-2)
jnz (-2), $word_skip_blanks
# skip LF
eq (0), $10, (-2)
jnz (-2), $word_skip_blanks
# skip CR
eq (0), $13, (-2)
jnz (-2), $word_skip_blanks
# else...
jz $0, $word_valid_char
word_til_blank: in (0)
eq (0), $9, (-2)
jnz (-2), $word_ret
eq (0), $32, (-2)
jnz (-2), $word_ret
eq (0), $10, (-2)
jnz (-2), $word_ret
eq (0), $13, (-2)
jnz (-2), $word_ret
word_valid_char: add (-1), $word_buf, word_dst
add $0, (0), word_dst: 0
add $1, (-1), (-1)
# check length!
eq (-1), $32, (-2)
jnz (-2), $word_ret
jz $0, $word_til_blank
word_ret: rel $-1
add $0, $word_buf, (-1)
jz $0, $_next
word_buf: .zeroes 32

$word
$0
$0
.ascip "NUMBER" # (ptr len -- num n-unparsed)
number: $number_code
number_code: rel $5 # temporaries: num n-unparsed char cnd neg
add $0, $0, (-3)
add $0, $0, (-4)
jz (-5), $number_ret # fail if 0-length input
add $0, (-6), number_first
eq $45, number_first: 0, (0) # check for negative sign
jz (0), $number_loop
# skip negative sign
add $-1, (-5), (-5)
add $1, (-6), (-6)

number_loop: jz (-5), $number_ret
add $0, (-6), number_src
add $0, number_src: 0, (-2)
lt (-2), $48, (-1)
jnz (-1), $number_fail
lt (-2), $58, (-1)
jnz (-1), $number_digit
lt (-2), $65, (-1)
jnz (-1), $number_fail
lt (-2), $91, (-1)
jnz (-1), $number_alpha
jz $0, $number_fail

number_digit: add $-48, (-2), (-2)
jz $0, $number_accum

number_alpha: add $-55, (-2), (-2)
jz $0, $number_accum

number_accum: lt (-2), base, (-1)
jz (-1), $number_fail
mul (-4), base, (-4)
add (-4), (-2), (-4)
add $-1, (-5), (-5)
add $1, (-6), (-6)
jz $0, $number_loop

number_fail: add $0, (-5), (-3)
number_ret: jz (0), $number_no_negate
mul $-1, (-4), (-4)
number_no_negate: rel $-5
add $0, (1), (-1)
add $0, (2), (0)
jz $0, $_next

# somewhat more "magic" words

$number
$0
$0
.ascip "EXIT"
exit: $exit_code
exit_code: add $-1, rstack_bp, rstack_bp
add $0, rstack_bp, exit_pop_src
add $0, exit_pop_src: 0, ip
jz $0, $_next

_next: add $0, ip, _jnext1
add $0, _jnext1: 0, _jnext2
add $1, ip, ip
jz $0, _jnext2: 0

_halt: $halt_code
halt_code: hlt

# assumption: data stack will be larger than return stack
# return stack will have a max capacity of 64
rstack_bp: $rstack
rstack: .zeroes 64
stack: $0
